# 技術選定

開発者としてステージが上がると、技術選定をする機会が増えます。

* Markdown形式のドキュメントを使うことになったので、ライブラリを選ぶか自作するか考える
* チャートを描画しないといけないので、ライブラリを選ぶか自作するか考える
* 新しいシステム開発を行うことになったので、アーキテクチャを選ぶ
* 新しいシステム開発を行うことになってので、プログラミング言語を選ぶ
* 新しい（省略）、フレームワークを選ぶ、ライブラリを選ぶ

技術選定をするときに考えるべき基準をこの章では書き記します。

## 技術を選定するとは

開発を行うときに、技術というのはあくまで手段です。何かしらの問題を解決するための開発にせよ、何かしらの研究を行うにせよ、なぜ「それ」を選ぶのか？というのには根拠を持って選ばなければなりません。

新しいシステムを開発するときに、アーキテクチャの選択をミスすれば、工数にも大きく影響することでしょう。同様に開発手法、言語、フレームワーク、ライブラリなどは、大なり小なり、大きくその後に響くものです。

普通は思いつく限りの選択肢に対して、いわゆる pros/cons （良し悪し）を列挙し、どれを選んだときにはどういう利点と欠点があるかを比較します。技術には大体において一長一短あり、どれが最善手であるか？はなかなか分からないものです[^you-are-gorilla]。

[^you-are-gorilla]: 極論を言えば、あなたが教育・メンテナンスできる技術であれば、どのような技術を採用しても文句を言われることは少ないでしょう。


## 技術を選定する基準

技術には、いくつかの指標があります。

* その技術についての情報が豊富
* その技術の使いやすさ
* その技術の中身
* その技術を扱える人材はどれくらいいるか？
* その技術の、今の人気、将来の人気
* その技術はn年後進化しているか？メンテナンスされているか？
* その技術の独自性はどれくらいある？代替案はある？

こういった指標がありますが、これらは対立することもあり、どの項目を優先するか悩むことも多いでしょう。

### その技術についての情報が豊富

おそらくこの項目を検討する人は多いでしょう。

情報が豊富であれば、よくハマりがちな問題は大体誰かが解決していることを期待できますし、自分が遭遇するいろいろな事例に対して、すでに答えがあることを期待できるでしょう。

ただし、それらが本当に正しいとは限らず見せかけだけの場合もあります。情報がいっぱい出てきても大半は「やってみた」程度のもので、深く踏み込んだ詳細な情報が無いというケースもあり得ます。とはいえ、情報が多ければ、その分有用なものに出会える可能性は高いかもしれません。

情報が豊富なときの利点は、その情報に到達する人が多いということでもあります。つまり、その技術を使える人材が豊富かもしれません。

### その技術の使いやすさ

使いやすさの基準は、その技術の使い方が分かりやすいこと、その技術がシンプルだったりイージーだったりすること、検索すれば情報が出てくること、ドキュメントや事例が豊富なことなどが挙げられるでしょう。情報が豊富という項目は前述の通りなので置いておきますが、大体連動することが多いでしょう。

使い方が分かりやすいかどうかは、作り手のセンスが表れます。例えばライブラリであれば、その言語のセオリーやエコシステム、あるいはプログラミング全般におけるセオリーと矛盾が少ないか？扱う上で面倒が少ないか？などです。矛盾が少ないということは直感的に扱いやすいはずです。

また、シンプルな技術や、イージーな技術も好まれがちです。あるライブラリを使うときに、やたらと手順が必要なものが好まれないことは自明です。

インストールのしやすさ、設定項目の少なさなんかも影響するでしょう。最近はゼロコンフィグと呼ばれるような設定しなくても大体いい感じにしてくれる技術が人気です。

プログラミングの原則に開放/閉鎖原則というものがあります。簡単にいうと拡張しやすく、修正をしなくていいようにするという原則です。ライブラリでいえばプラグインの仕組みやコールバック関数など拡張するための方法が用意されているなど、ライブラリの中に踏み込まなくても自由度が高いというのが理想的です。

#### その技術の使いやすさはメンテナンスしやすさにつながるか？

使いやすくても、その後メンテナンスしづらくなることもあります。たとえば、拡張性が低い場合、拡張するために無理矢理いろいろなものをねじ曲げる事例もあります。そういったコードは、最初は良かったのに後で苦労するという典型例です。

#### [column] シンプル vs イージー

シンプルとは、複雑ではなく、筋の通った分かりやすいロジックで成り立っているもののことです。

イージーとは、複雑かもしれないが、使い手にとって、簡単なことです。

もちろん、シンプルなコア技術の上にイージーを構築することはできます。それがおそらく理想型です。

一概にいえるわけではありませがん、イージーな技術は「最初は良かったのに後で苦労する」ケースがあるかもしれません。

このシンプル vs イージー問題は割と根深く、プログラミングの歴史においては何度も繰り返し登場している問題です。

技術選定をするときには少しだけ、この観点について敏感になった方が良いでしょう。

#### [/column]

### その技術の中身

使いやすさは、技術を利用する側の視点ですが、技術の中身が重要なこともあります。

あるいは、もしあなたがその技術のバグを見つけても、対処ができないかもしれません。理想型は、あなたが利用する技術は、あなた自身がパッチを当てられることです。あるいは、あなたが使っている技術のソースコードを追いかけられることです。

あなたが中身についてソースコードを追いかけたら実は思っていたことと違うこともあります。ドキュメントが間違っていた、読み間違えていた、バグがあったなどです。

ではあなた自身の力が及ばず、中身なんてさっぱりだわという場合、この観点は無視してもいいのでしょうか？そうではありません。たとえば中身があまりにも複雑怪奇な職人芸の場合、拡張性や将来のメンテナンスを期待できないかもしれません。つまり、その技術に未来が無いかもしれないのです。

場合によっては、あなたが理解できたとして貢献を絶対に受け付けないような偏屈な人・集団で開発されていません。どういった性質のコミュニティなのか？も見極めるべきポイントです。

最低限、その技術にどれくらい未来があるか？位は判定できるだけの力は身につけておくべきでしょう。

### その技術を扱える人材はどれくらいいるか？

いま、現在その技術を扱える人はどれくらいいるでしょうか？そしてその扱える人たちの技術力の分布はどのようなものでしょうか？素人に毛が生えたような人ばかりいても戦力になるとは限りません。職人芸を持った人たちばかりだと雇うのにも苦労するかもしれません。

あなたの組織、お金、文化、そういったものと適合しているか？はとても重要です。

また、いま現在、人が多くても、5年後、あるいは10年後はどうでしょうか？

あなたはどれくらいはやり廃りを予測できますか？

#### [column] はやり廃りを予想するのは難しい

スマートフォンが世界を席巻したのは2010年代です。たとえばiPhoneが日本に上陸した2008年、あなたはそれを予見できましたか？

クラウドが当たり前の現代です。2006年にAWSが登場しました。2000年代にクラウド全盛になることを予見できましたか？

JavaScriptが当たり前の時代です。JS/TSは人気もシェアもとても高い言語です。ウェブ開発において無視できない存在です。たとえば2010年代前半までにそれを予見できましたか？

Dockerなどコンテナ技術が当たり前の時代です。Dockerが登場したのは2014年です。それから数年でコンテナが当たり前になることをあなたは予見できましたか？

こうやって見ると、今当たり前とされている技術が登場してから、ある分野を完全に制覇するまでにかかる時間は、思ったよりもとても短いです。10年スパンではやり廃りを予測するのはなかなか難しいということが実感できたのではないでしょうか。

#### [/column]

### その技術はn年後進化しているか？メンテナンスされているか？

これはさきほどの

> また、いま現在、人が多くても、5年後、あるいは10年後はどうでしょうか？
>
> あなたはどれくらいはやり廃りを予測できますか？

ということと完全につながっている話です。

はやり廃りが激しいため、あなたが触っている技術が5年後、10年後にちゃんとメンテナンスされているか？というのはそれなりに難しく、それでいて簡単に致命傷になりうる問題です。

メンテナが飽きて放置されているかもしれません。どこかの企業が作ったものだけど中の人がメンテナンスを諦めて負債になっているケースも珍しくはありません。

#### [column] 5年後くらいまでは予測したうえで、10年後の予測を諦めるという選択肢

技術に対するセンサーを磨けば5年程度の予測は十分可能です。10年後の未来は諦めて5年後リプレイスできるような仕掛けを施しておくという選択肢もあるでしょう。

#### [/column]

#### [column] 決定をなるべく先延ばしにする

技術の基礎というのは陳腐化しづらいものです。とにかく陳腐化しづらい技術だけ先に決めておいて、フレームワーク選定などはなるべく先延ばしにしつつ、なるべく依存しないという考え方があります。

TBD: クリーンアーキテクチャ本を引用する

#### [/column]
